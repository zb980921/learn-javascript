不管什么样的编程语言，运行的时候必须对内存进行管理。不同的是，有些编程语言，需要程序员手动管理（C、C++、早期的OC），而有些编程语言会自动帮助我们管理内存（Java、JavaScript、Python、Swift、Dart等）。

- 不管以什么方式管理内存，内存的管理都会有如下的**生命周期**：
    - 第一步：分配申请你需要的内存
    - 第二步：使用分配的内存
    - 第三步：不需要使用时，对其进行释放
- JavaScript会在定义数据时为我们分配内存
    - 原始数据类型，直接在栈空间进行分配
    - 复杂数据类型，在堆内存中开辟一块空间，并且将这块空间的指针返回给变量引用

# 垃圾回收 - Garbage Collection

## 1. 引用计数  Reference counting

- 当一个对象有一个引用指向它时，这个对象的引用就+1
- 当一个对象的引用为0时，这个对象就可以被销毁掉。
- 弊端：循环引用

## 2. 标记清除  Mark-Sweep - V8

- 核心思路：可达性 Reachability
- 设置一个跟对象 root object，垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没用引用到的对象，就认为是不可用的对象。
- 这个算法可以很好的解决循环引用的问题

# 优化手段

## 1. 标记整理 Mark-Compact

与标记清除相似，不同的是，会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化。

## 2. 分代收集 Generational collection

对象被分成两组：新的、旧的

- 许多对象出现，完成他们的工作并很快死去，他们可以很快被清理
- 长期存活的对象会变得老旧，被检查的频次会减少

## 3. 增量收集 Incremental collection

- 如果有许多对象，试图一次遍历并标记整个对象集，可能需要一些时间，会在执行过程中带来明显的延迟
- 引擎试图将垃圾收集工作分成几个部分来做，然后将这几部门逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟

## 4. 闲时收集 Idle-time collection

- 垃圾回收器只会在CPU空闲时尝试运行，以减少可能对代码执行的影响